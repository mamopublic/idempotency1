experiment:
  iterations: 30
  output_dir: "experiments"
  save_artifacts: true
  ball_window_size: 10
  normalize_mermaid: true  # Option A: per-step Mermaid code normalizer (strips cosmetic variance)

models:
  generation_params:
    text_temperature: 0.1 # Low temp for deterministic code generation
    vision_temperature: 0.7 # Higher temp for creative/varied description
    
  # Text Model: GPT-4o-mini for Mermaid generation
  # DeepSeek R1 was too slow (crawls during generation)
  text_model: "openai/gpt-4o-mini"
  # text_model: "deepseek/deepseek-r1-0528-qwen3-8b"  # Too slow
  
  # Vision Model: Gemini Flash is sufficient for diagram description
  vision_model: "google/gemini-2.0-flash-001"
  
  # Rescue Model: Fallback when primary model fails after max retries
  rescue_model: "openai/gpt-4o"
  rescue_retries: 3
  # rescue_strategy options:
  #   "fix"        - rescue model receives the broken code + error and patches it (current behavior)
  #   "regenerate" - rescue model discards the broken code and regenerates from the current prompt
  rescue_strategy: "fix"
  
  # Alternatives:
  # text_model: "openai/gpt-4o-mini"  # Struggled with Mermaid syntax (empty edge labels)
  # text_model: "google/gemini-2.0-flash-001"  # Economical but weaker code gen
  # vision_model: "openai/gpt-4o-mini"
  # text_model: "mistralai/pixtral-12b"  # Vision-focused, not ideal for code
  # vision_model: "mistralai/pixtral-12b"
  
  # Embedding model for similarity analysis (must be a full HuggingFace model ID)
  embedding_model: "google/siglip-so400m-patch14-384"  # Options: "google/siglip-so400m-patch14-384", "titan"

# Semantic Entropy Analysis
semantic_entropy:
  n_clusters: 16  # Number of k-means clusters
  tau: 0.1        # Softmax temperature for soft assignment (lower = harder)
  random_state: 42
  embedding_model: "google/siglip-so400m-patch14-384"

mermaid:
  executable_path: "npx" # Assumes npx is in PATH

# Option B: Tight system prompts to reduce cosmetic/stylistic LLM variance
# When use_tight_prompts: true, the prompts under `tight_system_prompts` are used
# instead of `system_prompts`. Tight prompts constrain cosmetic choices (class names,
# styling properties, capitalization) to reduce noise in similarity metrics.
prompts:
  use_tight_prompts: false  # Set to true to use tight_system_prompts below

system_prompts:
  diagram_generation: |
    You are an expert software architect and Mermaid.js specialist.
    Your task is to generate a valid Mermaid.js diagram based on the user's description.
    
    RULES:
    1. Return ONLY the Mermaid code. No markdown code blocks (```mermaid), no explanations, no preamble.
    2. The code must be syntactically correct and renderable.
    3. Use the 'graph TD' or 'flowchart TD' type unless specified otherwise.
    4. Use clear, descriptive node labels.
    5. Style the nodes to look professional (e.g., using 'classDef').
    6. Do NOT use reserved keywords (like 'end', 'subgraph', 'click') as class names. Use 'endNode' instead of 'end'.

  vision_extraction: |
    You are an expert system analyst.
    Your task is to analyze the provided architecture diagram and write a detailed textual prompt that describes it.
    
    RULES:
    1. The output should be a prompt that, if fed to an architect, would result in this exact diagram.
    2. Describe every node, connection, and label.
    3. Capture the logical flow and hierarchy.
    4. Do NOT mention that you are looking at a diagram or image. Just describe the system.
    5. Be precise and concise.

# Tight system prompts: constrain cosmetic variance to isolate structural drift
tight_system_prompts:
  diagram_generation: |
    You are an expert software architect and Mermaid.js specialist.
    Your task is to generate a valid Mermaid.js diagram based on the user's description.
    
    RULES:
    1. Return ONLY the Mermaid code. No markdown code blocks (```mermaid), no explanations, no preamble.
    2. The code must be syntactically correct and renderable.
    3. Use the 'graph TD' type (not 'flowchart').
    4. Use clear, descriptive node labels.
    5. Always define exactly one class using classDef with the name 'nodeStyle'.
       Example: classDef nodeStyle fill:#f9f,stroke:#333,stroke-width:2px;
       Do NOT add rx, ry, or any other layout properties to classDef.
    6. Apply the class to all nodes using: class Node1,Node2,... nodeStyle
    7. Use 'endNode' (lowercase e) instead of the reserved keyword 'end'. Never use 'EndNode' or 'END'.
    8. Do NOT use reserved keywords (like 'end', 'subgraph', 'click') as node IDs or class names.

  vision_extraction: |
    You are an expert system analyst.
    Your task is to analyze the provided architecture diagram and write a structural description.
    
    RULES:
    1. The output should be a prompt that, if fed to an architect, would result in this exact diagram.
    2. Describe ONLY the logical structure: every node (its name and role), every directed connection, and every edge label.
    3. Do NOT describe visual styling, colors, shapes, border widths, or layout (rounded corners, etc.).
    4. Do NOT mention that you are looking at a diagram or image. Just describe the system.
    5. Be precise and concise. Focus on semantics, not aesthetics.

costs:
  # Rates per 1M tokens (USD)
  google/gemini-2.0-flash-001:
    input: 0.10
    output: 0.40
  openai/gpt-4o-mini:
    input: 0.15
    output: 0.60
  openai/gpt-4o:
    input: 2.50
    output: 10.00
  deepseek/deepseek-r1-qwen-8b:
    input: 0.14
    output: 0.28
  # Other models (for reference):
  # qwen/qwen-2.5-72b-instruct: ~$0.35/$0.40 (strong reasoning)
